package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"math"
	"os"
	"strconv"
	"sync"
)

type Restorans struct {
	GlobalId string     `json:"global_id"`
	ID string     `json:"ID"`
	Name string     `json:"Name"`
	IsNetObject string     `json:"IsNetObject"`
	OperatingCompany string     `json:"OperatingCompany"`
	TypeObject string     `json:"TypeObject"`
	AdmArea string     `json:"AdmArea"`
	Longitude_WGS84 interface{}     `json:"Longitude_WGS84"`
	Latitude_WGS84 interface{}    `json:"Latitude_WGS84"`
	Path float64

}

type restArray [] Restorans


func readJSON(filepath string) (array restArray){

	jsonFile, _ := os.Open(filepath)
	defer jsonFile.Close()

	byteValue, _ := ioutil.ReadAll(jsonFile)
	json.Unmarshal(byteValue, &array)

	return array
}

func Path(Longitude float64, Latitude float64, r Restorans) float64 {
	var f float64
	var w float64
	var h float64
	w = r.Latitude_WGS84.(float64)
	h = r.Longitude_WGS84.(float64)

	f =  math.Sqrt(math.Pow(Latitude - w, 2) + math.Pow(Longitude - h, 2))
	return  f
}

func ArrayDelimeter(maxLen int, array  restArray) ([] restArray) {
	x := len(array)
	destArray := [] restArray{}
	if (x>maxLen){
		res1:= ArrayDelimeter(maxLen, array[:(x/2)])
		res2:= ArrayDelimeter(maxLen, array[(x/2):])
		for i:=0; i<len(res1);i++ {
			destArray = append(destArray, res1[i])
		}
		for i:=0; i<len(res2);i++ {
			destArray = append(destArray, res2[i])
		}

	} else {
		destArray = append(destArray, array)
	}
	return destArray
}

func main() {
	if len(os.Args) == 1 {
		fmt.Println("Нет аргументов")
		os.Exit(1)
	}
	arguments := os.Args
	lat, _ := strconv.ParseFloat(arguments[2], 64)
	lon, _ := strconv.ParseFloat(arguments[3], 64)
	arr := ArrayDelimeter(100, readJSON("data.json"))
	fmt.Println(lat)
	fmt.Println(lon)
	fmt.Println(arr)

	var wg sync.WaitGroup

	for item := range arr {
		wg.Add(1)
		go func (array restArray, lat float64, lon float64, group *sync.WaitGroup) (restArray) {
			tempArray := make(restArray,0)
			for item := range array {
				pathToRest := Path(lon, lat, array[item])
				tmpVal:= array[item] //текущий ресторан
				tmpVal.Path = pathToRest
				tempArray = append(tempArray, tmpVal)
			}
			//сортировка
			
			defer wg.Done()
			
			return tempArray[:3]
		} (arr[item], lat, lon, &wg)
		
	}
	wg.Wait()
}
